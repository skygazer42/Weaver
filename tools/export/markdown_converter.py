"""
Markdown to PDF/DOCX/HTML Converter.

Converts markdown research reports to various export formats with styling.
"""

import base64
import io
import logging
import re
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, Optional, Union

logger = logging.getLogger(__name__)

# Check for optional dependencies
try:
    import markdown
    MARKDOWN_AVAILABLE = True
except ImportError:
    markdown = None
    MARKDOWN_AVAILABLE = False

try:
    from weasyprint import HTML as WeasyprintHTML, CSS
    WEASYPRINT_AVAILABLE = True
except ImportError:
    WeasyprintHTML = None
    CSS = None
    WEASYPRINT_AVAILABLE = False

try:
    from docx import Document
    from docx.shared import Inches, Pt
    from docx.enum.text import WD_ALIGN_PARAGRAPH
    DOCX_AVAILABLE = True
except ImportError:
    Document = None
    DOCX_AVAILABLE = False

try:
    from jinja2 import Environment, FileSystemLoader, BaseLoader
    JINJA2_AVAILABLE = True
except ImportError:
    Environment = None
    JINJA2_AVAILABLE = False


# Default HTML template for reports
DEFAULT_HTML_TEMPLATE = """<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title }}</title>
    <style>
        {{ css }}
    </style>
</head>
<body>
    <div class="report-container">
        <header class="report-header">
            <h1>{{ title }}</h1>
            <div class="report-meta">
                <span class="date">Generated: {{ generated_at }}</span>
                {% if thread_id %}
                <span class="thread-id">Thread: {{ thread_id }}</span>
                {% endif %}
            </div>
        </header>

        <main class="report-content">
            {{ content | safe }}
        </main>

        {% if sources %}
        <section class="sources">
            <h2>Sources</h2>
            <ul>
            {% for source in sources %}
                <li><a href="{{ source }}">{{ source }}</a></li>
            {% endfor %}
            </ul>
        </section>
        {% endif %}

        <footer class="report-footer">
            <p>Generated by Weaver Research Agent</p>
        </footer>
    </div>
</body>
</html>
"""

# Default CSS styling
DEFAULT_CSS = """
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    line-height: 1.6;
    color: #333;
    background-color: #f8f9fa;
}

.report-container {
    max-width: 900px;
    margin: 0 auto;
    padding: 40px;
    background-color: #fff;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
}

.report-header {
    border-bottom: 2px solid #3498db;
    padding-bottom: 20px;
    margin-bottom: 30px;
}

.report-header h1 {
    font-size: 2em;
    color: #2c3e50;
    margin-bottom: 10px;
}

.report-meta {
    font-size: 0.9em;
    color: #7f8c8d;
}

.report-meta span {
    margin-right: 20px;
}

.report-content {
    min-height: 400px;
}

.report-content h1 {
    font-size: 1.8em;
    color: #2c3e50;
    margin-top: 30px;
    margin-bottom: 15px;
    border-bottom: 1px solid #eee;
    padding-bottom: 10px;
}

.report-content h2 {
    font-size: 1.5em;
    color: #34495e;
    margin-top: 25px;
    margin-bottom: 12px;
}

.report-content h3 {
    font-size: 1.25em;
    color: #34495e;
    margin-top: 20px;
    margin-bottom: 10px;
}

.report-content p {
    margin-bottom: 15px;
    text-align: justify;
}

.report-content ul, .report-content ol {
    margin-left: 30px;
    margin-bottom: 15px;
}

.report-content li {
    margin-bottom: 8px;
}

.report-content blockquote {
    border-left: 4px solid #3498db;
    padding-left: 20px;
    margin: 20px 0;
    color: #555;
    font-style: italic;
}

.report-content code {
    background-color: #f4f4f4;
    padding: 2px 6px;
    border-radius: 3px;
    font-family: 'Consolas', 'Monaco', monospace;
    font-size: 0.9em;
}

.report-content pre {
    background-color: #2d2d2d;
    color: #f8f8f2;
    padding: 15px;
    border-radius: 5px;
    overflow-x: auto;
    margin: 15px 0;
}

.report-content pre code {
    background-color: transparent;
    padding: 0;
    color: inherit;
}

.report-content table {
    width: 100%;
    border-collapse: collapse;
    margin: 20px 0;
}

.report-content th, .report-content td {
    border: 1px solid #ddd;
    padding: 12px;
    text-align: left;
}

.report-content th {
    background-color: #3498db;
    color: white;
}

.report-content tr:nth-child(even) {
    background-color: #f9f9f9;
}

.report-content img {
    max-width: 100%;
    height: auto;
    margin: 15px 0;
    border-radius: 5px;
}

.report-content a {
    color: #3498db;
    text-decoration: none;
}

.report-content a:hover {
    text-decoration: underline;
}

.sources {
    margin-top: 40px;
    padding-top: 20px;
    border-top: 1px solid #eee;
}

.sources h2 {
    font-size: 1.3em;
    color: #2c3e50;
    margin-bottom: 15px;
}

.sources ul {
    list-style: none;
    margin-left: 0;
}

.sources li {
    margin-bottom: 8px;
    padding: 5px 0;
}

.sources a {
    color: #3498db;
    text-decoration: none;
    word-break: break-all;
}

.sources a:hover {
    text-decoration: underline;
}

.report-footer {
    margin-top: 40px;
    padding-top: 20px;
    border-top: 1px solid #eee;
    text-align: center;
    color: #7f8c8d;
    font-size: 0.9em;
}

/* Print styles */
@media print {
    body {
        background-color: white;
    }

    .report-container {
        box-shadow: none;
        padding: 0;
        max-width: none;
    }

    .report-header {
        page-break-after: avoid;
    }

    h1, h2, h3 {
        page-break-after: avoid;
    }

    pre, blockquote {
        page-break-inside: avoid;
    }
}

/* PDF-specific styles */
@page {
    size: A4;
    margin: 2cm;
}
"""


class MarkdownConverter:
    """
    Converts markdown content to various output formats.

    Supports HTML, PDF (via WeasyPrint), and DOCX (via python-docx).
    """

    def __init__(
        self,
        template_dir: Optional[str] = None,
        css_path: Optional[str] = None,
    ):
        """
        Initialize the converter.

        Args:
            template_dir: Directory containing Jinja2 templates
            css_path: Path to custom CSS file
        """
        self.template_dir = template_dir
        self.custom_css = None

        if css_path:
            css_file = Path(css_path)
            if css_file.exists():
                self.custom_css = css_file.read_text(encoding="utf-8")

        # Set up Jinja2 environment if available
        self.jinja_env = None
        if JINJA2_AVAILABLE and Environment is not None:
            if template_dir and Path(template_dir).exists():
                self.jinja_env = Environment(
                    loader=FileSystemLoader(template_dir),
                    autoescape=True,
                )
            else:
                # Use string-based loader for default template
                from jinja2 import BaseLoader

                class StringLoader(BaseLoader):
                    def __init__(self, template_string):
                        self.template_string = template_string

                    def get_source(self, environment, template):
                        return self.template_string, None, lambda: True

                self.jinja_env = Environment(
                    loader=StringLoader(DEFAULT_HTML_TEMPLATE),
                    autoescape=True,
                )

    def markdown_to_html_content(self, markdown_text: str) -> str:
        """
        Convert markdown text to HTML content (body only).

        Args:
            markdown_text: Markdown content

        Returns:
            HTML content string
        """
        if not MARKDOWN_AVAILABLE or markdown is None:
            # Basic fallback: wrap in paragraphs
            paragraphs = markdown_text.split("\n\n")
            html_parts = []
            for p in paragraphs:
                p = p.strip()
                if not p:
                    continue
                if p.startswith("# "):
                    html_parts.append(f"<h1>{p[2:]}</h1>")
                elif p.startswith("## "):
                    html_parts.append(f"<h2>{p[3:]}</h2>")
                elif p.startswith("### "):
                    html_parts.append(f"<h3>{p[4:]}</h3>")
                elif p.startswith("- "):
                    items = p.split("\n")
                    li_items = "".join(f"<li>{item[2:]}</li>" for item in items if item.startswith("- "))
                    html_parts.append(f"<ul>{li_items}</ul>")
                else:
                    html_parts.append(f"<p>{p}</p>")
            return "\n".join(html_parts)

        # Use python-markdown with extensions
        md = markdown.Markdown(
            extensions=[
                "extra",
                "codehilite",
                "tables",
                "toc",
                "nl2br",
            ],
            extension_configs={
                "codehilite": {"linenums": False},
            },
        )
        return md.convert(markdown_text)

    def to_html(
        self,
        markdown_text: str,
        title: str = "Research Report",
        thread_id: Optional[str] = None,
        sources: Optional[list] = None,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> str:
        """
        Convert markdown to complete HTML document.

        Args:
            markdown_text: Markdown content
            title: Document title
            thread_id: Optional thread ID for reference
            sources: Optional list of source URLs
            metadata: Optional additional metadata

        Returns:
            Complete HTML document string
        """
        html_content = self.markdown_to_html_content(markdown_text)
        css = self.custom_css or DEFAULT_CSS

        context = {
            "title": title,
            "content": html_content,
            "css": css,
            "generated_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "thread_id": thread_id,
            "sources": sources or [],
            **(metadata or {}),
        }

        if self.jinja_env:
            try:
                template = self.jinja_env.get_template("report.html")
            except Exception:
                # Fall back to default template
                template = self.jinja_env.from_string(DEFAULT_HTML_TEMPLATE)
            return template.render(**context)

        # Manual template rendering if Jinja2 not available
        html = DEFAULT_HTML_TEMPLATE
        html = html.replace("{{ title }}", title)
        html = html.replace("{{ content | safe }}", html_content)
        html = html.replace("{{ css }}", css)
        html = html.replace("{{ generated_at }}", context["generated_at"])
        html = html.replace("{{ thread_id }}", thread_id or "")

        # Handle sources
        if sources:
            sources_html = "".join(f'<li><a href="{s}">{s}</a></li>' for s in sources)
            html = html.replace("{% for source in sources %}", "")
            html = html.replace("{% endfor %}", "")
            html = re.sub(r'\{\{ source \}\}', "", html)

        return html

    def to_pdf(
        self,
        markdown_text: str,
        output_path: Optional[str] = None,
        title: str = "Research Report",
        thread_id: Optional[str] = None,
        sources: Optional[list] = None,
    ) -> Union[bytes, str]:
        """
        Convert markdown to PDF.

        Args:
            markdown_text: Markdown content
            output_path: Optional file path to save PDF
            title: Document title
            thread_id: Optional thread ID
            sources: Optional source URLs

        Returns:
            PDF bytes if no output_path, else the output path
        """
        if not WEASYPRINT_AVAILABLE or WeasyprintHTML is None:
            raise ImportError(
                "WeasyPrint is required for PDF export. "
                "Install with: pip install weasyprint"
            )

        html_content = self.to_html(markdown_text, title, thread_id, sources)

        # Create PDF
        html_doc = WeasyprintHTML(string=html_content)

        if output_path:
            html_doc.write_pdf(output_path)
            logger.info(f"[Export] PDF saved to: {output_path}")
            return output_path

        # Return bytes
        pdf_buffer = io.BytesIO()
        html_doc.write_pdf(pdf_buffer)
        return pdf_buffer.getvalue()

    def to_docx(
        self,
        markdown_text: str,
        output_path: Optional[str] = None,
        title: str = "Research Report",
        thread_id: Optional[str] = None,
        sources: Optional[list] = None,
    ) -> Union[bytes, str]:
        """
        Convert markdown to DOCX.

        Args:
            markdown_text: Markdown content
            output_path: Optional file path to save DOCX
            title: Document title
            thread_id: Optional thread ID
            sources: Optional source URLs

        Returns:
            DOCX bytes if no output_path, else the output path
        """
        if not DOCX_AVAILABLE or Document is None:
            raise ImportError(
                "python-docx is required for DOCX export. "
                "Install with: pip install python-docx"
            )

        doc = Document()

        # Add title
        title_para = doc.add_heading(title, level=0)
        title_para.alignment = WD_ALIGN_PARAGRAPH.CENTER

        # Add metadata
        meta_para = doc.add_paragraph()
        meta_para.add_run(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        if thread_id:
            meta_para.add_run(f" | Thread: {thread_id}")
        meta_para.alignment = WD_ALIGN_PARAGRAPH.CENTER

        doc.add_paragraph()  # Spacer

        # Parse and add markdown content
        self._add_markdown_to_docx(doc, markdown_text)

        # Add sources if available
        if sources:
            doc.add_heading("Sources", level=1)
            for source in sources:
                p = doc.add_paragraph(style="List Bullet")
                p.add_run(source)

        # Add footer
        doc.add_paragraph()
        footer = doc.add_paragraph("Generated by Weaver Research Agent")
        footer.alignment = WD_ALIGN_PARAGRAPH.CENTER

        if output_path:
            doc.save(output_path)
            logger.info(f"[Export] DOCX saved to: {output_path}")
            return output_path

        # Return bytes
        docx_buffer = io.BytesIO()
        doc.save(docx_buffer)
        return docx_buffer.getvalue()

    def _add_markdown_to_docx(self, doc, markdown_text: str) -> None:
        """
        Parse markdown and add content to DOCX document.

        Args:
            doc: python-docx Document object
            markdown_text: Markdown content
        """
        lines = markdown_text.split("\n")
        current_list = None

        for line in lines:
            line = line.rstrip()

            if not line:
                if current_list:
                    current_list = None
                continue

            # Headings
            if line.startswith("# "):
                doc.add_heading(line[2:], level=1)
                current_list = None
            elif line.startswith("## "):
                doc.add_heading(line[3:], level=2)
                current_list = None
            elif line.startswith("### "):
                doc.add_heading(line[4:], level=3)
                current_list = None
            elif line.startswith("#### "):
                doc.add_heading(line[5:], level=4)
                current_list = None
            # Bullet lists
            elif line.startswith("- ") or line.startswith("* "):
                p = doc.add_paragraph(line[2:], style="List Bullet")
                current_list = "bullet"
            # Numbered lists
            elif re.match(r"^\d+\.\s", line):
                content = re.sub(r"^\d+\.\s", "", line)
                p = doc.add_paragraph(content, style="List Number")
                current_list = "number"
            # Blockquotes
            elif line.startswith("> "):
                p = doc.add_paragraph()
                p.add_run(line[2:]).italic = True
                current_list = None
            # Code blocks
            elif line.startswith("```"):
                current_list = None
                # Skip code fence markers
            # Regular paragraphs
            else:
                # Handle inline formatting
                text = self._process_inline_formatting(doc, line)
                current_list = None

    def _process_inline_formatting(self, doc, text: str) -> None:
        """
        Process inline markdown formatting and add to document.

        Args:
            doc: python-docx Document object
            text: Line of text with potential inline formatting
        """
        p = doc.add_paragraph()

        # Split by bold/italic markers
        # This is a simplified implementation
        parts = re.split(r"(\*\*.*?\*\*|\*.*?\*|`.*?`)", text)

        for part in parts:
            if not part:
                continue

            if part.startswith("**") and part.endswith("**"):
                # Bold
                run = p.add_run(part[2:-2])
                run.bold = True
            elif part.startswith("*") and part.endswith("*"):
                # Italic
                run = p.add_run(part[1:-1])
                run.italic = True
            elif part.startswith("`") and part.endswith("`"):
                # Code
                run = p.add_run(part[1:-1])
                run.font.name = "Consolas"
            else:
                p.add_run(part)


# Convenience functions
def to_html(
    markdown_text: str,
    title: str = "Research Report",
    thread_id: Optional[str] = None,
    sources: Optional[list] = None,
) -> str:
    """Convert markdown to HTML."""
    converter = MarkdownConverter()
    return converter.to_html(markdown_text, title, thread_id, sources)


def to_pdf(
    markdown_text: str,
    output_path: Optional[str] = None,
    title: str = "Research Report",
    thread_id: Optional[str] = None,
    sources: Optional[list] = None,
) -> Union[bytes, str]:
    """Convert markdown to PDF."""
    converter = MarkdownConverter()
    return converter.to_pdf(markdown_text, output_path, title, thread_id, sources)


def to_docx(
    markdown_text: str,
    output_path: Optional[str] = None,
    title: str = "Research Report",
    thread_id: Optional[str] = None,
    sources: Optional[list] = None,
) -> Union[bytes, str]:
    """Convert markdown to DOCX."""
    converter = MarkdownConverter()
    return converter.to_docx(markdown_text, output_path, title, thread_id, sources)


def export_report(
    markdown_text: str,
    format: str = "html",
    output_path: Optional[str] = None,
    title: str = "Research Report",
    thread_id: Optional[str] = None,
    sources: Optional[list] = None,
) -> Union[bytes, str]:
    """
    Export markdown report to specified format.

    Args:
        markdown_text: Markdown content
        format: Output format (html, pdf, docx)
        output_path: Optional output file path
        title: Document title
        thread_id: Optional thread ID
        sources: Optional source URLs

    Returns:
        Output content (bytes or string) or file path
    """
    converter = MarkdownConverter()

    format_lower = format.lower()

    if format_lower == "html":
        html = converter.to_html(markdown_text, title, thread_id, sources)
        if output_path:
            Path(output_path).write_text(html, encoding="utf-8")
            logger.info(f"[Export] HTML saved to: {output_path}")
            return output_path
        return html

    elif format_lower == "pdf":
        return converter.to_pdf(markdown_text, output_path, title, thread_id, sources)

    elif format_lower in ("docx", "doc"):
        return converter.to_docx(markdown_text, output_path, title, thread_id, sources)

    else:
        raise ValueError(f"Unsupported format: {format}. Use html, pdf, or docx.")
